01.アプリケーションドメインとはなにか？
A.アプリケーションの基本的な概念と機能をプログラマに提供する方法。
02.理想的な命名とはなにか？
A.論理的に異なる操作には、それぞれ違った適した名前をつける。論理的に等しい演算子には同じ名前をつける。
03.何に名前をつけることができるか？
A.関数やクラス
04.Shapeが提供するサービスはなにか？
A.グラフィックス/GUIビューのすべての図形に共通するものを提供する。
05.抽象クラスと非抽象クラスとの違いはなにか？
A.抽象クラスは基底クラスとしてのみ使用する。
06.クラスを抽象クラスにするにはどうすればいいか？
A.純粋仮想関数を定義する。または基底クラスに設定する。クラスの実装上の詳細をprivateにして直接使用できないようにする。（カプセル化。）
07.アクセス制限によってなにが制御されるか？
A.表現を保護することで、クラスの設計者が予想していなかった方法で表現が変更されることがなくなり、より少ない作業で良いクラスを作成できる。
08.データメンバをprivateにすることにどのような効果があるか？
A.それが宣言されたクラスのメンバしかそれを使用できなくなる。
09.仮想関数とはなにか？非仮想関数との違いはなにか？
A.仮想関数をは純粋なインターフェイスを提供する。それらはデータメンバを持たず、コンストラクタをもたない傾向がある。
10.基底クラスとはなにか？
A.それは抽象概念を表すことが多く直接の使用に適さない場合が多い。派生クラスにメンバを継承させる。
11.クラスを派生させるにはどうすればいいか？
A.あるクラスを別のクラスから構築し、元のクラスの代わりに新しいクラスを使用できるようにする方法。
12.オブジェクトのレイアウトとは何を意味するか？
A.オブジェクトのメモリ内でのレイアウト、メンバによって定義されるもの。
13.クラスをテストしやすくするにはどうすればよいか？
A.単純さと拡張性を保ったクラスを設計する。
14.継承図とはなにか？
A.継承関係を視覚化するためにクラスの階層関係を表したもの。
15.protectedメンバとprivateメンバの違いはなにか？
A.privateはクラス固有のメンバのみがアクセスできる。protectedは派生クラスと基底クラスのメンバがアクセスできる。
16.派生クラスからアクセスできるクラスのメンバはなにか？
A.publicとprotected
17.純粋仮想関数と他の関数の違いはなにか？
A.純粋仮想関数は派生クラスでオーバーライドされなければいけない。
18.メンバ関数を仮想にするのはなぜか？
A.純粋なインターフェイスを提供したいから。
19.仮想メンバ関数を純粋にするのはなぜか？
A.必ず派生クラスでオーバーライドさせるため。
20.オーバーライドは何を意味するか？
A.基底クラスで提供されるインターフェイスを通じてそれを使用できるようにすること。
21.インターフェイスの継承と実装の継承との違いはなにか？
A.インターフェイスの継承を通じて、基底クラスを期待する関数は、派生クラスを受け取ることができる。実装の継承を通じて、派生クラスとそのメンバ関数を定義する際に、基底クラスによって提供される機能を利用することができる。
22.オブジェクト指向プログラミングとはなにか？
A.継承、実行時ポリモーフィズム、カプセル化などを使用したプログラミング。